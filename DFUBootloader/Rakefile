require 'rake'
require 'pathname'
#require 'fileutils'

verbose(ENV['verbose'] == '1')

PROG = 'dfuloader'

# include a defaults file if present
load 'rakefile.defaults' if File.exists?('rakefile.defaults')

DEBUG = ENV['debug'] == '1'
DEBUGLIB = ENV['debuglib'] == '1'

$using_cpp= false

if ENV['target'].nil?
  TARGET = 'Nucleo'
  #TARGET = 'Devebox'
elsif (ENV['target'] != 'Nucleo' && ENV['target'] != 'Prime'&& ENV['target'] != 'Devebox')
  puts "ERROR: Must specify target=[Nucleo|Prime|Devebox]"
  exit 0
else
  TARGET = ENV['target']
end

puts "Target is #{TARGET}"

target_defines= []
# configure main DEBUG UART port to use
if TARGET == 'Prime'
  target_defines << '-DUSE_UART0'
  target_defines << "-DUART0_PINSET=15"
elsif TARGET == 'Nucleo'
  target_defines << '-DUSE_UART3'
  target_defines << '-DUART3_PINSET=8'
elsif TARGET == 'Devebox'
  target_defines << '-DUSE_UART4'
  target_defines << '-DUART4_PINSET=8'
else
	raise "Unknown target #{TARGET}"
end


def pop_path(path)
  Pathname(path).each_filename.to_a[1..-1]
end

def obj2src(fn, e)
  File.absolute_path(File.join(pop_path(File.dirname(fn)), File.basename(fn).ext(e)))
end

# Makefile .d file loader to be used with the import file loader.
# this emulates the -include $(DEPFILES) in a Makefile for the generated .d files
class DfileLoader
  include Rake::DSL

  SPACE_MARK = "\0"

  # Load the makefile dependencies in +fn+.
  def load(fn)
    return if ! File.exists?(fn)
    lines = File.read fn
    lines.gsub!(/\\ /, SPACE_MARK)
    lines.gsub!(/#[^\n]*\n/m, "")
    lines.gsub!(/\\\n/, ' ')
    lines.each_line do |line|
      process_line(line)
    end
  end

  private

  # Process one logical line of makefile data.
  def process_line(line)
    file_tasks, args = line.split(':', 2)
    return if args.nil?
    dependents = args.split.map { |d| respace(d) }
    file_tasks.scan(/\S+/) do |file_task|
      file_task = respace(file_task)
      file file_task => dependents
    end
  end

  def respace(str)
    str.tr SPACE_MARK, ' '
  end
end

# Install the handler
Rake.application.add_loader('d', DfileLoader.new)

TOOLSDIR = ENV['ARMTOOLS'].nil? ? '/usr/bin' :  ENV['ARMTOOLS']
TOOLSBIN = "#{TOOLSDIR}/arm-none-eabi-"
LIBSDIR = "#{TOOLSDIR}/../lib"
CC = "#{TOOLSBIN}gcc"
CCPP = "#{TOOLSBIN}g++"
LD = "#{TOOLSBIN}gcc"
LDCPP = "#{TOOLSBIN}c++"
OBJCOPY = "#{TOOLSBIN}objcopy"
OBJDUMP = "#{TOOLSBIN}objdump"
SIZE = "#{TOOLSBIN}size"
AR = "#{TOOLSBIN}ar"
ARFLAGS = 'ur'

current_version= `#{CC} -dumpversion`.chomp
puts "Current GCC version is #{current_version}"
#ARMVERSION = ENV['ARMVERSION'].nil? ? current_version :  ENV['ARMVERSION']

# HAL files
hal_src = FileList["Drivers/Src/*.{c,cpp,s}"]
hal_src.exclude(/_template\.c/)

# the startup file
startup_src = FileList["startup_stm32h7xx.s"]

usb_src = FileList["XPD_USB/*.{c,cpp,s}", "USBDevice/Device/*.c", "USBDevice/Class/DFU/usbd_dfu.c"]

# application
app_src = FileList["Src/**/*.{c,cpp,s}"]

# All sources
SRCS = hal_src + usb_src + startup_src + app_src

# Library sources
HAL_SRCS = hal_src

APP_SRCS = app_src + usb_src + startup_src

$using_cpp= SRCS.find { |i| File.extname(i) == ".cpp" }.nil? ? false : true

OBJDIR = "Build"
OBJ = APP_SRCS.collect { |fn| File.join(OBJDIR, File.dirname(fn), File.basename(fn).ext('o')) }

HAL_OBJ = HAL_SRCS.collect { |fn| File.join(OBJDIR, File.dirname(fn), File.basename(fn).ext('o')) }
OBJS = HAL_OBJ + OBJ

# list of header dependency files generated by compiler
DEPFILES = OBJS.collect { |fn| File.join(File.dirname(fn), File.basename(fn).ext('d')) }

# create destination directories
SRCS.each do |s|
  d= File.join(OBJDIR, File.dirname(s))
  FileUtils.mkdir_p(d) unless Dir.exists?(d)
end

include_dirs = []
include_dirs << 'Inc'
include_dirs << 'Src'
include_dirs << 'XPD_USB'
include_dirs << 'USBDevice/PDs/STM32_XPD'
include_dirs << 'USBDevice/Include'
include_dirs << 'Drivers'
include_dirs << 'Drivers/cmsis'
include_dirs << 'Drivers/Inc'

sys_include_dirs = []

# [Dir.glob([PROG + '/**/Inc/**', './mri/**/'])].flatten

INCLUDE = (include_dirs).collect { |d| "-I#{d}" }.join(" ")

defines = %w(-DUSE_HAL_DRIVER  -DCORE_CM7 -DUSE_FULL_LL_DRIVER)
if DEBUG
  defines << "-DDEBUG"
end

# Target specified #defines
defines << "-DBUILD_TARGET=\\\"#{TARGET}\\\" "
if TARGET == 'Nucleo'
  defines << '-DBOARD_NUCLEO'
  defines << '-DSTM32H745xx'
  defines << '-DHSE_VALUE=8000000'
elsif TARGET == 'Prime'
  defines << '-DBOARD_PRIME'
  defines << '-DSTM32H745xx'
  defines << '-DHSE_VALUE=25000000'
elsif TARGET == 'Devebox'
  defines << '-DBOARD_DEVEBOX'
  defines << '-DSTM32H743xx'
  defines << '-DHSE_VALUE=25000000'
else
  raise("Error unhandled target")
end

defines += target_defines

DEFINES= defines.join(' ')

DEPFLAGS = '-MMD '
CSTD = ' -std=gnu11 '
FFLAGS = ' -ffunction-sections -fstack-usage '
CPUFLGS = '-mcpu=cortex-m7 -mfpu=fpv5-d16 -mfloat-abi=hard -mthumb '
SPECS = ' --specs=nano.specs '
CFLAGS = CSTD + FFLAGS + CPUFLGS + DEPFLAGS + " -Wall  " + (DEBUG ? "-O0 -g3 " : "-O2 -g") +  SPECS
CPPFLAGS = CFLAGS + ' -Wno-psabi -fno-exceptions -fno-rtti -fno-common -std=gnu++14'

# find Linker script to be used.
if TARGET == 'Nucleo'
	if DEBUG
		LSCRIPT = "STM32H7xx_FLASH.ld"
		puts "compiled for address 0x08000000"
	else
		LSCRIPT = "STM32H7xx_HIGH_FLASH.ld"
		puts "compiled for address 0x081E0000"
	end
else
LSCRIPT = "STM32H7xx_QSPI_FLASH.ld"
puts "compiled for address 0x90000000"
end

LOPTIONS = ['-mcpu=cortex-m7', '--specs=nosys.specs', '-Wl,-print-memory-usage', "-Wl,-Map=#{OBJDIR}/#{PROG}.map", "-Wl,--gc-sections", "-static", '--specs=nano.specs', '-mfpu=fpv5-d16', '-mfloat-abi=hard', '-mthumb', '-Wl,--start-group', '-lc', '-lm', '-Wl,--end-group']
LDFLAGS = " -T#{LSCRIPT} " + LOPTIONS.join(" ")

# generate the header dependencies if they exist
import(*DEPFILES)

# tasks
# desc "Upload via stlink"
# task :upload do
#   sh "./flashit #{OBJDIR}/#{PROG}.bin"
# end

desc 'clean build'
task :clean do
  FileUtils.rm_rf(OBJDIR)
end

desc 'only clean src and tests'
task :cleansrc do
  FileUtils.rm_rf("#{OBJDIR}/src")
  FileUtils.rm_rf("#{OBJDIR}/TestUnits")
end

desc 'only clean tests'
task :cleantests do
  FileUtils.rm_rf("#{OBJDIR}/TestUnits")
end

desc 'default is to build'
task :default => [:build] #, :size]

desc 'default is to build'
task :build => ["#{OBJDIR}/#{PROG}.bin"]

desc 'get size of build'
task :size do
  sh "#{SIZE} #{OBJDIR}/#{PROG}.elf"
end

desc 'get disasm of build'
task :disasm do
  sh "#{OBJDUMP} -d -f -M reg-names-std --demangle #{OBJDIR}/#{PROG}.elf > #{OBJDIR}/#{PROG}.disasm"
end

desc "Upload"
task :upload do
  if TARGET == 'Nucleo'
    sh "~/bin/flash-stm32 #{OBJDIR}/#{PROG}.bin"
  elsif TARGET == 'Devebox'
    # sh "upload-ym.py -f #{OBJDIR}/#{PROG}.bin USB0"
    sh "download-dl.py -f #{OBJDIR}/#{PROG}.bin ACM0"
  else
    die "Unknown upload protocol for target #{TARGET}"
  end
end

file "#{OBJDIR}/#{PROG}.bin" => ["#{OBJDIR}/#{PROG}.elf"] do |t|
  puts "Creating #{t.name}"
  sh "#{OBJCOPY} -O binary #{OBJDIR}/#{PROG}.elf #{OBJDIR}/#{PROG}.bin"
  sh "md5sum #{OBJDIR}/#{PROG}.bin | cut -c1-32 | tr -d '\\n' > #{OBJDIR}/#{PROG}.md5"
end

file "#{OBJDIR}/#{PROG}.elf" => ["#{OBJDIR}/libhal.a"] + OBJ do |t|
  puts "Linking #{t.name}"
  sh "#{LD} #{OBJ} -L#{OBJDIR} -lhal #{LDFLAGS} -o #{t.name}"
end

file "#{OBJDIR}/libhal.a" => HAL_OBJ do |t|
  puts "Creating #{t.name}"
  sh "#{AR} #{ARFLAGS} #{t.name} #{HAL_OBJ}"
end

#arm-none-eabi-objcopy -R .stack -O ihex ../LPC1768/main.elf ../LPC1768/main.hex
#arm-none-eabi-objdump -d -f -M reg-names-std --demangle ../LPC1768/main.elf >../LPC1768/main.disasm

rule '.o' => lambda{ |objfile| obj2src(objfile, 'cpp') } do |t|
  puts "Compiling #{t.source}"
  sh "#{CCPP} #{CPPFLAGS} #{INCLUDE} #{DEFINES} #{$version} -c -o #{t.name} #{t.source}"
end

rule '.o' => lambda{ |objfile| obj2src(objfile, 'c') } do |t|
  puts "Compiling #{t.source}"
  sh "#{CC} #{CFLAGS} #{CSTD} #{INCLUDE} #{DEFINES} #{$version} -c -o #{t.name} #{t.source}"
end

rule '.o' => lambda{ |objfile| obj2src(objfile, 's') } do |t|
  puts "Assembling #{t.source}"
  sh "#{CC} -c --specs=nano.specs -mthumb -mcpu=cortex-m7 -mthumb-interwork -mlittle-endian -mfloat-abi=hard -mfpu=fpv5-sp-d16 -g -Wa,--no-warn -x assembler-with-cpp #{INCLUDE} -o #{t.name} #{t.source}"
end
